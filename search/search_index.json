{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HomeConvDO","text":"Convolutional Differential Operators for Physics-based Deep Learning Study Calculate the spatial derivative differentiablly!"},{"location":"#installation","title":"Installation","text":"<ul> <li>Install through pip: <code>pip install ConvDO</code></li> <li>Install the latest version through pip: <code>pip install git+https://github.com/qiauil/ConvDO</code></li> <li>Install locally: Download the repository and run <code>./install.sh</code> or <code>pip install .</code></li> </ul>"},{"location":"#feature","title":"Feature","text":"<p>Positive\ud83d\ude00 and negative\ud83d\ude43 things are all features... </p> <ul> <li>PyTorch-based and only supports 2D fields at the moment.</li> <li>Powered by convolutional neural network.</li> <li>Differentiable and GPU supported (why not? It's PyTorch based!).</li> <li>Second order for Dirichlet and Neumann boundary condition.</li> <li>Up to 8th order for periodic boundary condition.</li> <li>Obstacles inside of the domain is supported.</li> </ul>"},{"location":"#further-reading","title":"Further Reading","text":"<p>Projects using <code>ConvDO</code>:</p> <ul> <li>Diffusion-based-Flow-Prediction: Diffusion-based flow prediction (DBFP) with uncertainty for airfoils.</li> <li>To be updated... </li> </ul> <p>If you need to solve more complex PDEs using differentiable functions, please have a check on</p> <ul> <li>PhiFlow: A differentiable PDE solving framework for machine learning</li> <li>Exponax: Efficient Differentiable n-d PDE solvers in JAX.</li> </ul> <p>For more research on physics based deep learning research, please visit the website of our research group at TUM. </p>"},{"location":"expindex/","title":"Getting Started","text":"<p>How to use ConvDO</p>"},{"location":"expindex/#here-is-an-example-api-documentation","title":"Here is an example API documentation","text":""},{"location":"expindex/#ConvDO.FieldOperations","title":"ConvDO.FieldOperations","text":"<p>A class that performs various operations on fields.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the operations.</p> required <code>device</code> <code>str</code> <p>The device to perform the operations on. Defaults to \"cpu\".</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type of the operations. Defaults to torch.float32.</p> <code>float32</code> <p>Attributes:</p> Name Type Description <code>nabla</code> <code>ConvNabla</code> <p>The gradient operator.</p> <code>nabla2</code> <code>ConvLaplacian</code> <p>The Laplacian operator.</p> <code>grad_x</code> <code>ConvGrad</code> <p>The gradient operator in the x direction.</p> <code>grad_y</code> <code>ConvGrad</code> <p>The gradient operator in the y direction.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>class FieldOperations():\n    r\"\"\"\n    A class that performs various operations on fields.\n\n    Args:\n        order (int): The order of the operations.\n        device (str, optional): The device to perform the operations on. Defaults to \"cpu\".\n        dtype (torch.dtype, optional): The data type of the operations. Defaults to torch.float32.\n\n    Attributes:\n        nabla (ConvNabla): The gradient operator.\n        nabla2 (ConvLaplacian): The Laplacian operator.\n        grad_x (ConvGrad): The gradient operator in the x direction.\n        grad_y (ConvGrad): The gradient operator in the y direction.\n    \"\"\"\n\n    def __init__(self, order:int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n        self.nabla = ConvNabla(order, device=device, dtype=dtype)\n        self.nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n        self.grad_x = ConvGrad(order, direction='x', device=device, dtype=dtype)\n        self.grad_y = ConvGrad(order, direction='y', device=device, dtype=dtype)\n        self.grad2_x = ConvGrad2(order, direction='x', device=device, dtype=dtype)\n        self.grad2_y = ConvGrad2(order, direction='y', device=device, dtype=dtype)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"expindex/#ConvDO.FieldOperations.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int, device=\"cpu\", dtype=torch.float32\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, order:int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n    self.nabla = ConvNabla(order, device=device, dtype=dtype)\n    self.nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n    self.grad_x = ConvGrad(order, direction='x', device=device, dtype=dtype)\n    self.grad_y = ConvGrad(order, direction='y', device=device, dtype=dtype)\n    self.grad2_x = ConvGrad2(order, direction='x', device=device, dtype=dtype)\n    self.grad2_y = ConvGrad2(order, direction='y', device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/examples/divergence/","title":"Divergence Operator","text":"<pre><code>import torch\nimport matplotlib.pyplot as plt\n\nflow= torch.load('../../binaries/kf_flow.pt')\nchannel_names=[\"u\",\"v\"]\n\nfigs, axs = plt.subplots(1, 2)\nfor i, ax in enumerate(axs):\n    ax.imshow(flow[i].numpy(),origin='lower')\n    ax.set_title(channel_names[i])\nplt.show()\n</code></pre> <p>To calculate the divergence of this flow field, we can simply build a <code>Divergence</code> operator:</p> <pre><code>from ConvDO import *\n\nclass Divergence(FieldOperations):\n\n    def __init__(self, \n                 domain_u:Domain,\n                 domain_v:Domain,\n                 order:int, \n                 device=\"cpu\", \n                 dtype=torch.float32) -&amp;gt; None:\n        super().__init__(order, device, dtype)\n        self.velocity=VectorValue(ScalarField(domain=domain_u),ScalarField(domain=domain_v))\n\n    def __call__(self, u:torch.Tensor,v:torch.Tensor):\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        return (self.nabla@self.velocity).value\n</code></pre> <p>The <code>domain_u</code> and <code>domain_v</code> should be instances of the <code>Domain</code> class, which gives the boundary condition of the fields.</p> <p>The <code>order</code> here refers to the order of the finite difference scheme used to calculate the derivate. For periodic boundary conditions, supported orders include <code>2,4,6,8</code>. For un-periodic boundaries, only a second-order scheme is available.</p> <p>The <code>device</code> and <code>dtype</code> should be inconsistent with the tensor used for the operation.</p> <p>We use the <code>VectorValue</code> class to generate the velocity; the component of the vector is two <code>ScalarField</code> initialized with the velocity tensor and the corresponding domain. The <code>VectorValue</code> class also supports numerical numbers as its component, and we can perform some simple operations on the <code>VectorValue</code>: </p> <pre><code>a=VectorValue(1,2)\nb=VectorValue(3,4)\nc=a+b\nd=a-b\ne=5*a\nf=a@b\nprint(c,d,e,f)\n</code></pre> <pre>\n<code>(4,6) (-2,-2) (5,10) 11\n</code>\n</pre> <p><code>self.nabla</code> is the nabla operator, \\(\\nabla\\). Other supported operator includes the Laplacian operator <code>self.nabla2</code> = \\(\\nabla^2\\) and gradient operators <code>self.grad_x</code> = \\(\\partial/\\partial x\\) and <code>self.grad_y</code> = \\(\\partial/\\partial y\\). For instance, the <code>Divergence</code> operator can also be written as</p> <pre><code>class Divergence_new(FieldOperations):\n\n    def __init__(self, \n                 domain_u:Domain,\n                 domain_v:Domain,\n                 order:int, \n                 device=\"cpu\", \n                 dtype=torch.float32) -&amp;gt; None:\n        super().__init__(order, device, dtype)\n        self.u=ScalarField(domain=domain_u)\n        self.v=ScalarField(domain=domain_v)\n\n    def __call__(self, u:torch.Tensor,v:torch.Tensor):\n        self.u.register_value(u)\n        self.v.register_value(v)\n        return (self.grad_x*self.u+self.grad_y*self.v).value\n</code></pre> <p>If you want to use these operators out of the <code>FieldOperations</code> class, you can also simply create them as follows:</p> <pre><code>nabla = ConvNabla(order=2)\nnabla2 = ConvLaplacian(order=2)\ngrad_x = ConvGrad(order=2,direction=\"x\")\ngrad_y = ConvGrad(order=2,direction=\"y\")\n</code></pre> <p>Then, we can set up the computational domain of the field and calculate the divergence. The boundary condition of Kolmogorov flow is periodic thus we will set up a periodic domain. Here, <code>delta_x</code> and <code>delta_y</code> is the physical distance between mesh cells in the field. Besides <code>PeriodicDomain</code>, you can directly use the <code>Domain</code> class to add different boundary conditions and even obstacles inside the field. </p> <p>Now, let's calculate the divergence!</p> <pre><code>u=flow[0]\nv=flow[1]\ndomain=PeriodicDomain(delta_x=2*3.14/64,delta_y=2*3.14/64)\ndivergence=Divergence(order=6,domain_u=domain,domain_v=domain)\nresidual=divergence(u,v).numpy().squeeze().squeeze()\nplt.imshow(residual,origin=\"lower\")\nplt.title(\"Divergence\")\nplt.colorbar()\nplt.show()\n</code></pre> <p>Since the operation is based on the convolution provided by PyTorch, it supports batched input and output. If your input of a <code>ScalarField</code> only contains 2 dimensions \\(H \\times W\\), it will automatically convert to a new tensor with the shape of \\(B\\times C \\times H \\times W\\). The shape of the output is always \\(B\\times C \\times H \\times W\\).</p>"},{"location":"contents/examples/divergence/#divergence-operator","title":"Divergence Operator","text":"<p>In this tutorial, we will show you how build a divergence operator with <code>ConvDo</code>.</p> <p> </p> <p>The divergence operator maps a vector field to a scalar field. The divergence operator for a vector field \\(\\mathbf{u}=[u,v]\\) is defined as follows:</p> \\[ \\nabla \\cdot \\mathbf{u}=\\frac{\\partial u}{\\partial x}+\\frac{\\partial v}{\\partial y} \\] <p>For a flow filed which satisfies the Navier-Stokes equation, the divergence of the velocity field should be zero, i.e., \\(\\nabla \\cdot \\mathbf{u}=0\\). Kolmogorov flow is a classical turbulent flow; a snapshot of the velocity is illustrated as follows:</p>"},{"location":"contents/examples/obstacles/","title":"Operator with obstacles","text":"<p>In this tutorial, we will show you how build operators when there are obstacles inside the computational domain.</p> <p> </p> <p>In many situations, the flow field may contain obstacles. For example, the flow around a cylinder is a classical problem in fluid dynamics. The flow field around a cylinder is illustrated as follows:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncyclinder_flow=torch.from_numpy(np.load(\"../../binaries/cyclinder.npy\"))\nchannel_names=[\"u\",\"v\",\"p\"]\nfigs, axs = plt.subplots(1, 3)\nfor i, ax in enumerate(axs):\n    ax.imshow(cyclinder_flow[i,:,:].numpy())\n    ax.set_title(channel_names[i])\nplt.show()\n</code></pre> <p>Besides the divergence free condition, the flow field should also satisfy the Momentum equation. The Momentum equation is a vector equation, which can be written as follows:</p> <p>$$ \\left{\\begin{matrix} {{\\partial u} \\over {\\partial t}} + {u {{\\partial u} \\over {\\partial x}}} + v {{\\partial u} \\over {\\partial y}} = -{1 \\over \\rho} {{\\partial p} \\over {\\partial x}} + \\nu \\left( {{\\partial^2 u} \\over {\\partial x^2}} + {{\\partial^2 u} \\over {\\partial y^2}} \\right)</p> <p>\\ {{\\partial v} \\over {\\partial t}} + {u {{\\partial v} \\over {\\partial x}}} + v {{\\partial v} \\over {\\partial y}} = -{1 \\over \\rho} {{\\partial p} \\over {\\partial y}} + \\nu \\left( {{\\partial^2 v} \\over {\\partial x^2}} + {{\\partial^2 v} \\over {\\partial y^2}} \\right)</p> <p>\\end{matrix}\\right. $$</p> <p>The above equation contains the transient derivative, which is hard to evaluate if we only have a snapshot of the flow field. Therefore, we can combine the divergence-free condition with the momentum equation to the Poisson equation for pressure:</p> \\[ -{1 \\over \\rho} \\left( {{\\partial^2 p} \\over {\\partial x^2}} + {{\\partial^2 p} \\over {\\partial y^2}} \\right) = \\left( {{\\partial u} \\over {\\partial x}} \\right)^2 + 2 {{\\partial u} \\over {\\partial y}} {{\\partial v} \\over {\\partial x}}+ \\left( {{\\partial v} \\over {\\partial y}} \\right)^2 \\] <p>To calculate the residual of Poisson equation and the divergence of the velocity field, we can build a operator as follows (for incompressible flow, the density \\(\\rho\\) is omitted):</p> <pre><code>from ConvDO import *\n\nclass PoissonDivergence(FieldOperations):\n    def __init__(self, \n                 domain_u: Domain,\n                 domain_v: Domain, \n                 domain_p: Domain, \n                 order: int,\n                 device=\"cpu\", \n                 dtype=torch.float32) -&amp;gt; None:\n        super().__init__(order, device=device, dtype=dtype)\n        self.pressure = ScalarField(domain=domain_p)\n        self.velocity = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n\n    def __call__(self, u, v, p):\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        self.pressure.register_value(p)\n        poisson = (self.nabla2*self.pressure)+(self.grad_x*self.velocity.ux)**2+2*(self.grad_y*self.velocity.ux)*(self.grad_x*self.velocity.uy)+(self.grad_y*self.velocity.uy)**2\n        divergence = self.nabla@self.velocity\n        return torch.cat([poisson.value, divergence.value], dim=-3)\n</code></pre> <p>You may notice that there is a cyclinder in the flow field. We can add the cylinder as an obstacle in the domain. The <code>Obstacle</code> class is used to add obstacles in the domain. The <code>Obstacle</code> class is initialized with the shape of the obstacle. The shape of the obstacle is a binary tensor with the same shape as the domain. The obstacle is a tensor with 0 and 1, where 0 represents the obstacle and 1 represents the calculation domain. The following code shows how generate a cylinder obstacle shape::</p> <pre><code>def generate_cylinder_2D(center_x,center_y,radius,length_x,length_y,dx=1,dy=1):\n    y, x=np.ogrid[0.5:int(length_y/dy)+0.5, 0.5:int(length_x/dx)+0.5]\n    x=x*dx\n    y=y*dy\n    dist_from_center = torch.tensor(np.sqrt((x - center_x)**2 + (y-center_y)**2))\n    return torch.where(dist_from_center &amp;lt; radius,0.0,1.0)\n\n# generate_cylinder_2D function is also available in the ConvDO module\nobstacles=generate_cylinder_2D(30,32,10,128,64)\n\nplt.imshow(obstacles,origin=\"lower\")\n</code></pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7d72bae26680&gt;</code>\n</pre> <p>Then we can build the domain where we can specify the boundary condition for each filed on the boundaries and obstacles:</p> <pre><code>domain_u=Domain(\n    boundaries=[\n        UnConstrainedBoundary(),\n        UnConstrainedBoundary(),\n        DirichletBoundary(0.45), # inflow\n        UnConstrainedBoundary()\n    ],\n    obstacles=[DirichletObstacle(shape_field=obstacles,boundary_value=0.0)]\n)\n\ndomain_v=Domain(\n    boundaries=[\n        UnConstrainedBoundary(),\n        UnConstrainedBoundary(),\n        DirichletBoundary(0),\n        UnConstrainedBoundary()\n    ],\n    obstacles=[DirichletObstacle(shape_field=obstacles,boundary_value=0.0)]\n)\n\ndomain_p=Domain(\n    boundaries=[\n        UnConstrainedBoundary(),\n        UnConstrainedBoundary(),\n        NeumannBoundary(0.0),\n        UnConstrainedBoundary()\n    ],\n    obstacles=[NeumannObstacle(shape_field=obstacles,boundary_gradient=0.0)]\n)\n</code></pre> <p>Now, let's calculate the residual of the Poisson equation and the divergence of the velocity field:</p> <pre><code>u=cyclinder_flow[0]\nv=cyclinder_flow[1]\np=cyclinder_flow[2]\noperator=PoissonDivergence(domain_u,domain_v,domain_p,order=2)\nresidual=operator(u.T,-1*v.T,p.T)\nchannel_names=[\"Poisson\",\"Divergence\"]\nfigs, axs = plt.subplots(1, 2)\nfor i, ax in enumerate(axs):\n    ax.imshow(residual[0,i,:,:].numpy(),origin=\"lower\")\n    ax.set_title(channel_names[i])\nplt.show()\n</code></pre> <p>You may wonder why we perform the transpose and change the sign of the y component of the velocity field. This is related to the coordinate system of the field in <code>ConvDO</code>. The following code clearly shows the difference between <code>ConvDO</code>'s \\(x,y\\) coordinates and Torch/Numpy's <code>Row/Column</code> coordinates</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfield=torch.zeros(1,1,63,127)\n# left boundary\nfield=torch.nn.functional.pad(field,(1,0,0,0),mode=\"constant\",value=1)\n# top boundary\nfield=torch.nn.functional.pad(field,(0,0,1,0),mode=\"constant\",value=2)\nprint(field.shape)\n# mesh: 128(x) * 64(y)\n\nplt.imshow(field.squeeze().squeeze().numpy())\nplt.xlabel(\"Column, \u2192\")\nplt.ylabel(\"Row, \u2190\")\nplt.title(\"Illustration of the default PyTorch/Numpy coordinate system.\")\nplt.show()\n\nplt.imshow(field.squeeze().squeeze().numpy())\nplt.xlabel(\"x, $\\mathbf{i}$, \u2192, (bottom)\")\nplt.ylabel(\"y, $\\mathbf{j}$, \u2192, (left)\")\nplt.yticks(range(0,64,8),[64-i for i in range(0,64,8)])\nplt.title(\"Illustration of the ConvDO coordinate system. \\n Vector $(x,y)$ is represented as $x \\mathbf{i}+y \\mathbf{j}$\")\nplt.show()\n</code></pre> <pre>\n<code>torch.Size([1, 1, 64, 128])\n</code>\n</pre> <p>In the original cylinder flow field, the \\(x\\) component of the velocity actually points to \\(-y\\) direction and the \\(y\\) component actually points to \\(x\\) direction. Thus, we need to do some modifications on their direction. It is always ideal to check the coordinate system of your data before calculate the residual.</p>"},{"location":"contents/examples/obstacles/#operator-with-obstacles","title":"Operator with obstacles","text":"<p>If you want to use these operators out of the <code>FieldOperations</code> class, you can also simply create them as follows:</p>"},{"location":"contents/examples/optimization/","title":"Optimization","text":"<pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom ConvDO import *\n\nclass Divergence(FieldOperations):\n\n    def __init__(self, \n                 domain_u:Domain,\n                 domain_v:Domain,\n                 order:int, \n                 device=\"cpu\", \n                 dtype=torch.float32) -&amp;gt; None:\n        super().__init__(order, device, dtype)\n        self.velocity=VectorValue(ScalarField(domain=domain_u),ScalarField(domain=domain_v))\n\n    def __call__(self, u:torch.Tensor,v:torch.Tensor):\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        return (self.nabla@self.velocity).value\n\nflow= torch.load('../../binaries/kf_flow.pt')\nu=flow[0]\nv=flow[1]\ndomain=PeriodicDomain(delta_x=2*3.14/64,delta_y=2*3.14/64)\ndivergence=Divergence(domain_u=domain,domain_v=domain,order=6)\n</code></pre> <p>Now, let's have a check on the residual of divergence before optimization:</p> <pre><code>channel_names=[\"u\",\"v\"]\nresidual=divergence(u,v)\nplt.imshow(residual.detach().numpy().squeeze().squeeze())\nplt.colorbar()\nplt.title(\"Residual before optimization\")\nplt.show()\n</code></pre> <p>We can decrease the divergence residual with the gradient descent optimization as we usually do for training a neural network:</p> <pre><code>losses=[]\noptimizer = torch.optim.Adam([u,v],lr=0.001)\nu.requires_grad=True\nv.requires_grad=True\n\nfor i in range(100):\n    optimizer.zero_grad()\n    residual=divergence(u,v)\n    loss=torch.mean(residual**2)\n    losses.append(loss.item())\n    loss.backward()\n    optimizer.step()\n\nplt.plot(losses)\nplt.show()\n</code></pre> <p>Now, its time to check on the result!</p> <pre><code>plt.imshow(residual.detach().numpy().squeeze().squeeze())\nplt.colorbar()\nplt.title(\"Final residual\")\nplt.show()\nfig, axs = plt.subplots(1, 2)\nfor i, ax in enumerate(axs):\n    ax.imshow(flow[i].detach().numpy())\n    ax.set_title(channel_names[i])\nplt.show()\n</code></pre> <pre><code>class SteadyNS(FieldOperations):\n\n    def __init__(self, Re:float,\n                 domain_u:Domain,\n                 domain_v:Domain,\n                 domain_p:Domain,\n                 order=2, \n                 device=\"cpu\",\n                 dtype=torch.float32) -&amp;gt; None:\n        super().__init__(order, device, dtype)\n        self.velocity=VectorValue(ScalarField(domain=domain_u),ScalarField(domain=domain_v))\n        self.pressure=ScalarField(domain=domain_p)\n        self.Re=Re\n\n    def __call__(self, \n                 u:torch.Tensor,\n                 v:torch.Tensor,\n                 p:torch.Tensor,):\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        self.pressure.register_value(p)\n\n        viscosity=self.nabla2*self.velocity*(1/self.Re)\n        momentum_x=self.grad_x*self.velocity.ux*self.velocity.ux+self.grad_y*self.velocity.ux*self.velocity.uy+self.grad_x*self.pressure-viscosity.ux\n        momentum_y=self.grad_x*self.velocity.uy*self.velocity.ux+self.grad_y*self.velocity.uy*self.velocity.uy+self.grad_y*self.pressure-viscosity.uy\n        divergence=self.nabla@self.velocity\n\n        return momentum_x.value.abs(),momentum_y.value.abs(),divergence.value.abs()\n</code></pre> <p>Now, Let's define the domain of the velocity and pressure:</p> <pre><code>N=128\n\ndomain_u=Domain(\n    boundaries=[\n        DirichletBoundary(0.0),\n        DirichletBoundary(0.0),\n        DirichletBoundary(1.0),\n        DirichletBoundary(0.0)],\n    delta_x=1.0/N,\n    delta_y=1.0/N,)\n\ndomain_v=Domain(boundaries=[DirichletBoundary(0.0)]*4,\n                delta_x=1.0/N,\n                delta_y=1.0/N,)\n\ndomain_p=Domain(boundaries=[NeumannBoundary(0.0)]*4,               \n                delta_x=1.0/N,\n                delta_y=1.0/N,)\n</code></pre> <p>Optimization start!</p> <pre><code>from tqdm import tqdm\n\noperator=SteadyNS(10,domain_u,domain_v,domain_p,order=2)        \nuvp=torch.zeros((3,N,N),requires_grad=True)\n# Working on GPU:\n#operator=SteadyNS(10,domain_u,domain_v,domain_p,order=2,device=\"cuda\")        \n#uvp=torch.zeros((3,N,N),requires_grad=True,device=\"cuda\")\noptimizer = torch.optim.Adam([uvp],lr=0.001)\nlosses=[]\n\np_bar=tqdm(range(50000))\nfor i in p_bar:\n    optimizer.zero_grad()\n    m_x,m_y,c=operator(uvp[0],uvp[1],uvp[2])\n    loss=m_x.sum()+m_y.sum()+c.sum()\n    loss.backward()\n    optimizer.step()\n    losses.append(loss.item())\n    p_bar.set_description(\"Loss: {:.3f}\".format(loss.item()))\nplt.plot(losses)\n</code></pre> <pre>\n<code>Loss: 38689.418: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 50000/50000 [06:18&lt;00:00, 132.26it/s]\n</code>\n</pre> <pre>\n<code>[&lt;matplotlib.lines.Line2D at 0x7d49b01c4d90&gt;]</code>\n</pre> <p>Now, lets visualize the results:</p> <pre><code>channel_names=[\"u\",\"v\",\"p\"]\nfig,ax=plt.subplots(1,3,figsize=(15,5))\nfor i in range(3):\n    ax[i].imshow(uvp[i].detach().numpy())\n    #ax[i].imshow(uvp[i].cpu().detach().numpy())\n    ax[i].set_title(channel_names[i])\nplt.show()\n\nchannel_names=[\"Momentum x\",\"Momentum y\",\"Divergence\"]\nresiduals=operator(uvp[0],uvp[1],uvp[2])\nfig,ax=plt.subplots(1,3,figsize=(15,5))\nfor i in range(3):\n    #ax[i].imshow(residuals[i].cpu().detach().numpy().squeeze().squeeze())\n    ax[i].imshow(residuals[i].detach().numpy().squeeze().squeeze())\n    ax[i].set_title(channel_names[i])\n\nplt.show()\n</code></pre> <p>Cool, we successfully get the flow field inside the cavity. In real applications, you may want to use a neural network to train a surrogate model for the flow simulator rather than directly optimize the field. This is also easy to be done with <code>ConvDO</code>, you can have a try by yourself. Enjoy!</p>"},{"location":"contents/examples/optimization/#optimization","title":"Optimization","text":"<p>In this tutorial, we will show you how to perform gradient based optimization with <code>ConvDo</code>.</p> <p> </p> <p>Let's start with <code>divergence</code> again. You may notice that the divergence of the Kolmogorov flow is not such perfect in the Divergence Operator tutorial. Thanks to PyTorch, all the operation is differentiable. Thus, we can directly use gradient descent method to make the flow field more divergence free.</p>"},{"location":"contents/examples/optimization/#make-it-more-divergence-free","title":"Make it more divergence free","text":"<p>First, Let's build the operator and load the dataset as we have done before:</p>"},{"location":"contents/examples/optimization/#solve-pdes","title":"Solve PDEs","text":"<p>We could also use <code>ConvDO</code> to solve some PDEs with gradient descent. For example, we could solve the 2D lid-driven cavity flow:</p> <p>$$ \\left{\\begin{matrix}  {u {{\\partial u} \\over {\\partial x}}} + v {{\\partial u} \\over {\\partial y}} = -{{\\partial p} \\over {\\partial x}} + \\frac{1}{Re} \\left( {{\\partial^2 u} \\over {\\partial x^2}} + {{\\partial^2 u} \\over {\\partial y^2}} \\right)</p> <p>\\ {u {{\\partial v} \\over {\\partial x}}} + v {{\\partial v} \\over {\\partial y}} = -{{\\partial p} \\over {\\partial y}} + \\frac{1}{Re} \\left( {{\\partial^2 v} \\over {\\partial x^2}} + {{\\partial^2 v} \\over {\\partial y^2}} \\right)</p> <p>\\ \\frac{\\partial u}{\\partial x}+\\frac{\\partial v}{\\partial y}=0 \\end{matrix}\\right. $$</p> <p>where \\(Re=\\frac{u_c l}{\\nu}\\) is the Reynolds number. In the lid-driven cavity flow case, \\(u_c\\) is the velocity of the upper boundary, \\(l\\) is the side length of the domain. The operator of these equations can be defined as:</p>"},{"location":"contents/guide/boundaries/","title":"Boundaries","text":""},{"location":"contents/guide/boundaries/#available-boundaries","title":"Available Boundaries","text":"Boundary Description <code>ConvDO.boundaries.DirichletBoundary</code> The value of the field is fixed at the boundary. <code>ConvDO.boundaries.NeumannBoundary</code> The gradient of the field is fixed at the boundary. <code>ConvDO.boundaries.UnConstrainedBoundary</code> The value of boundary is calculated by the value of the neighbour cells. If you are not sure about the boundary condition, you can use <code>UnConstrainedBoundary</code>. <code>ConvDO.boundaries.PeriodicBoundary</code> The value of boundary is determined by the opposite side of the domain"},{"location":"contents/guide/boundaries/#calculation-rule-of-boundaries","title":"Calculation Rule of Boundaries","text":"<ul> <li> <p>Dirichlet(a) + Dirichlet(b) = Dirichlet(a+b)</p> </li> <li> <p>Dirichlet(a) * Dirichlet(b) = Dirichlet(a*b)</p> </li> <li> <p>Dirichlet(a) + float(b) = Dirichlet(a+b)</p> </li> <li> <p>Dirichlet(a) * float(b) = Dirichlet(a*b)</p> </li> </ul> <ul> <li> <p>Dirichlet(a) + Neumann(b) = UnConstrained</p> </li> <li> <p>Dirichlet(a) * Neumann(b) = UnConstrained</p> </li> </ul> <ul> <li> <p>Neumann(a) + Neumann(b) = Neumann(a+b)</p> </li> <li> <p>Neumann(a) * Neumann(b) = UnConstrained</p> </li> <li> <p>Neumann(a) + float(b) = Neumann(a)</p> </li> <li> <p>Neumann(a) * float(b) = Neumann(a*b)</p> </li> </ul> <ul> <li> <p>UnConstrained + Other = UnConstrained</p> </li> <li> <p>UnConstrained * Other = UnConstrained</p> </li> </ul> <ul> <li> <p>Periodic + Periodic = Periodic</p> </li> <li> <p>Periodic * Periodic = Periodic</p> </li> <li> <p>Periodic + Other = UnConstrained</p> </li> <li> <p>Periodic * Other = UnConstrained</p> </li> </ul>"},{"location":"contents/guide/coordinate/","title":"Coordinate","text":"<p>The <code>x,y</code> coordinate system of <code>ConvDO</code> is different from the <code>Row/Column</code> system of <code>PyTorch/Numpy</code>. It is always ideal to check the coordinate system of your data before calculate the residual.</p> <p>See Operator with obstacles tutorial for more information.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfield=torch.zeros(1,1,63,127)\n# left boundary\nfield=torch.nn.functional.pad(field,(1,0,0,0),mode=\"constant\",value=1)\n# top boundary\nfield=torch.nn.functional.pad(field,(0,0,1,0),mode=\"constant\",value=2)\nprint(field.shape)\n# mesh: 128(x) * 64(y)\n\nplt.imshow(field.squeeze().squeeze().numpy())\nplt.xlabel(\"Column, \u2192\")\nplt.ylabel(\"Row, \u2190\")\nplt.title(\"Illustration of the default PyTorch/Numpy coordinate system.\")\nplt.show()\n\nplt.imshow(field.squeeze().squeeze().numpy())\nplt.xlabel(\"x, $\\mathbf{i}$, \u2192, (bottom)\")\nplt.ylabel(\"y, $\\mathbf{j}$, \u2192, (left)\")\nplt.yticks(range(0,64,8),[64-i for i in range(0,64,8)])\nplt.title(\"Illustration of the ConvDO coordinate system. \\n Vector $(x,y)$ is represented as $x \\mathbf{i}+y \\mathbf{j}$\")\nplt.show()\n</code></pre> <pre>\n<code>torch.Size([1, 1, 64, 128])\n</code>\n</pre>"},{"location":"contents/guide/domain/","title":"Domains","text":""},{"location":"contents/guide/domain/#general-domain","title":"General Domain","text":"<p>Domain gives the boundaries and obstacles of a physical field.</p> <p>A general domain is defined as</p> <p> Domain</p> <p>Parameters:</p> Name Type Description Default <code>boundaries</code> <code>Sequence</code> <p>A sequence of four boundary objects representing the boundary conditions.  The order is [left_boundary, right_boundary, top_boundary, bottom_boundary].</p> required <code>obstacles</code> <code>Sequence</code> <p>A sequence of obstacle objects representing the solid obstacles inside the domain. Defaults to [].</p> <code>[]</code> <code>delta_x</code> <code>float</code> <p>The grid spacing in the x direction. Defaults to 1.0.</p> <code>1.0</code> <code>delta_y</code> <code>float</code> <p>The grid spacing in the y direction. Defaults to 1.0.</p> <code>1.0</code>"},{"location":"contents/guide/domain/#special-domain","title":"Special Domain","text":"<p>We also give some functions that can quickly generate domains with specific boundaries: </p>"},{"location":"contents/guide/domain/#ConvDO.domain.UnconstrainedDomain","title":"ConvDO.domain.UnconstrainedDomain","text":"<pre><code>UnconstrainedDomain(obstacles=[], delta_x=1, delta_y=1)\n</code></pre> <p>Create a domain with unconstrained boundary conditions for all boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>obstacles</code> <code>list</code> <p>description. Defaults to [].</p> <code>[]</code> <code>delta_x</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>delta_y</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Domain</code> <code>Domain</code> <p>A domain object.</p> Source code in <code>ConvDO/domain.py</code> <pre><code>def UnconstrainedDomain(obstacles=[],delta_x=1,delta_y=1):\n    \"\"\"\n    Create a domain with unconstrained boundary conditions for all boundaries.\n\n    Args:\n        obstacles (list, optional): _description_. Defaults to [].\n        delta_x (int, optional): _description_. Defaults to 1.\n        delta_y (int, optional): _description_. Defaults to 1.\n\n    Returns:\n        Domain (Domain): A domain object.\n    \"\"\"\n    return Domain(boundaries=[UnConstrainedBoundary()]*4,obstacles=obstacles,delta_x=delta_x,delta_y=delta_y)\n</code></pre>"},{"location":"contents/guide/domain/#ConvDO.domain.PeriodicDomain","title":"ConvDO.domain.PeriodicDomain","text":"<pre><code>PeriodicDomain(obstacles=[], delta_x=1, delta_y=1)\n</code></pre> <p>Create a domain with periodic boundary conditions for all boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>obstacles</code> <code>list</code> <p>description. Defaults to [].</p> <code>[]</code> <code>delta_x</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <code>delta_y</code> <code>int</code> <p>description. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Domain</code> <code>Domain</code> <p>A domain object.</p> Source code in <code>ConvDO/domain.py</code> <pre><code>def PeriodicDomain(obstacles=[],delta_x=1,delta_y=1):\n    \"\"\"\n    Create a domain with periodic boundary conditions for all boundaries.\n\n    Args:\n        obstacles (list, optional): _description_. Defaults to [].\n        delta_x (int, optional): _description_. Defaults to 1.\n        delta_y (int, optional): _description_. Defaults to 1.\n\n    Returns:\n        Domain (Domain): A domain object.\n\n    \"\"\"\n    return Domain(boundaries=[PeriodicBoundary()]*4,obstacles=obstacles,delta_x=delta_x,delta_y=delta_y)\n</code></pre>"},{"location":"contents/guide/meta/","title":"Meta Variables","text":"<p>In <code>ConvDO</code>, all the operation is performed on <code>ScalarField</code> or <code>VectorValue</code>:</p>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField","title":"ConvDO.conv_operators.ScalarField","text":"<p>               Bases: <code>CommutativeValue</code></p> <p>ScalarField is a class for scalar fields.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[Tensor]</code> <p>The value of the scalar field. Defaults to None. It can be changed by calling the <code>register_value</code> method. The shape of the tensor should be (1,1,H,W) or (H,W).</p> <code>None</code> <code>domain</code> <code>Optional[Domain]</code> <p>The domain of the scalar field. Defaults to UnconstrainedDomain().</p> <code>UnconstrainedDomain()</code> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>class ScalarField(CommutativeValue):\n    r\"\"\"ScalarField is a class for scalar fields.\n\n    Args:\n        value (Optional[torch.Tensor], optional): The value of the scalar field. Defaults to None.\n            It can be changed by calling the `register_value` method.\n            The shape of the tensor should be (1,1,H,W) or (H,W).\n        domain (Optional[Domain], optional): The domain of the scalar field. Defaults to UnconstrainedDomain().\n    \"\"\"\n\n    def __init__(self,value:Optional[torch.Tensor]=None,\n                 domain:Optional[Domain]=UnconstrainedDomain()) -&gt; None:\n        self.value=None\n        if value is not None:\n            self.register_value(value)\n        self.domain=domain\n\n    def register_value(self,value: torch.Tensor):\n        r\"\"\"Register the value of the scalar field.\n\n        Args:\n            value (torch.Tensor): The value of the scalar field.\n        \"\"\"\n\n        if len(value.shape)==2:\n            value=value.unsqueeze(0).unsqueeze(0)\n        self.value=value\n\n    def __add__(self, other):\n        if isinstance(other,ScalarField):\n            return ScalarField(self.value+other.value,self.domain+other.domain)\n        else:\n            return ScalarField(self.value+other,self.domain+other)\n\n    def __mul__(self, other):\n        if isinstance(other,ScalarField):\n            return ScalarField(self.value*other.value,self.domain*other.domain)\n        else:\n            return ScalarField(self.value*other,self.domain*other)   \n\n    def __pow__(self, other):\n        return ScalarField(self.value**other,self.domain**other)\n\n    def __truediv__(self, other):\n        if isinstance(other,ScalarField):\n            return ScalarField(self.value/other.value,self.domain/other.domain)\n        else:\n            try:\n                return ScalarField(self.value/other,self.domain/other)\n            except:\n                return NotImplemented\n\n    def __rtruediv__(self, other):\n        if isinstance(other,ScalarField):\n            return ScalarField(other.value/self.value,other.domain/self.domain)\n        else:\n            try:\n                return ScalarField(other/self.value,other/self.domain)\n            except:\n                return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = None\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.domain","title":"domain  <code>instance-attribute</code>","text":"<pre><code>domain = domain\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __radd__(self, other):\n    return self+other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __iadd__(self,other):\n    return self+other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __sub__(self,other):\n    try:\n        return self+(-1*other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __rsub__(self,other):\n    try:\n        return other+(-1*self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __isub__(self,other):\n    return self-other    \n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __rmul__(self,other):\n    return self*other       \n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __imul__(self,other):\n    return self*other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__init__","title":"__init__","text":"<pre><code>__init__(\n    value: Optional[torch.Tensor] = None,\n    domain: Optional[Domain] = UnconstrainedDomain(),\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __init__(self,value:Optional[torch.Tensor]=None,\n             domain:Optional[Domain]=UnconstrainedDomain()) -&gt; None:\n    self.value=None\n    if value is not None:\n        self.register_value(value)\n    self.domain=domain\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.register_value","title":"register_value","text":"<pre><code>register_value(value: torch.Tensor)\n</code></pre> <p>Register the value of the scalar field.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Tensor</code> <p>The value of the scalar field.</p> required Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def register_value(self,value: torch.Tensor):\n    r\"\"\"Register the value of the scalar field.\n\n    Args:\n        value (torch.Tensor): The value of the scalar field.\n    \"\"\"\n\n    if len(value.shape)==2:\n        value=value.unsqueeze(0).unsqueeze(0)\n    self.value=value\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other,ScalarField):\n        return ScalarField(self.value+other.value,self.domain+other.domain)\n    else:\n        return ScalarField(self.value+other,self.domain+other)\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other,ScalarField):\n        return ScalarField(self.value*other.value,self.domain*other.domain)\n    else:\n        return ScalarField(self.value*other,self.domain*other)   \n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__pow__","title":"__pow__","text":"<pre><code>__pow__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __pow__(self, other):\n    return ScalarField(self.value**other,self.domain**other)\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __truediv__(self, other):\n    if isinstance(other,ScalarField):\n        return ScalarField(self.value/other.value,self.domain/other.domain)\n    else:\n        try:\n            return ScalarField(self.value/other,self.domain/other)\n        except:\n            return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.conv_operators.ScalarField.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __rtruediv__(self, other):\n    if isinstance(other,ScalarField):\n        return ScalarField(other.value/self.value,other.domain/self.domain)\n    else:\n        try:\n            return ScalarField(other/self.value,other/self.domain)\n        except:\n            return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue","title":"ConvDO.meta_type.VectorValue","text":"<p>A class to represent a 2D vector. Supports basic operations such as addition, subtraction, multiplication, division, and dot product. The vector is represented as a tuple (<code>ux</code>,<code>uy</code>), where <code>ux</code> and <code>uy</code> are the x and y components of the vector, respectively. The x/y components of the vector can be any type that supports the basic operations.</p> <p>Parameters:</p> Name Type Description Default <code>ux</code> <code>Any</code> <p>x-component of the vector</p> required <code>uy</code> <code>Any</code> <p>y-component of the vector</p> required Source code in <code>ConvDO/meta_type.py</code> <pre><code>class VectorValue():\n    \"\"\"\n    A class to represent a 2D vector.\n    Supports basic operations such as addition, subtraction, multiplication, division, and dot product.\n    The vector is represented as a tuple (`ux`,`uy`), where `ux` and `uy` are the x and y components of the vector, respectively.\n    The x/y components of the vector can be any type that supports the basic operations.\n\n    Args:\n        ux (Any): x-component of the vector\n        uy (Any): y-component of the vector\n    \"\"\"\n\n    def __init__(self,ux,uy) -&gt; None:\n        self.ux=ux\n        self.uy=uy\n\n    def __str__(self) -&gt; str:\n        return \"({},{})\".format(self.ux,self.uy)\n\n    # + \uff1a vector+scalar,vector+vector    \n    def __add__(self, other):\n        if isinstance(other,VectorValue):\n            return VectorValue(self.ux+other.ux,self.uy+other.uy)\n        else:\n            try:\n                return VectorValue(self.ux+other,self.uy+other)\n            except Exception:\n                return NotImplemented\n\n    def __radd__(self, other):\n        return self+other\n\n    def __iadd__(self,other):\n        return self+other\n\n    def __sub__(self,other):\n        try:\n            return self+(-1*other)\n        except Exception:\n            return NotImplemented\n\n    def __rsub__(self,other):\n        try:\n            return other+(-1*self)\n        except Exception:\n            return NotImplemented\n\n    def __isub__(self,other):\n        return self-other\n\n    # * \uff1a vectorvector, scalarvector            \n    def __mul__(self,other):\n        if isinstance(other,VectorValue):\n            return TensorValue(self.ux*other.ux,self.ux*other.uy,self.uy*other.ux,self.uy*other.uy)\n        else:\n            try:\n                return VectorValue(self.ux*other,self.uy*other)\n            except Exception:\n                return NotImplemented  \n\n    def __rmul__(self,other):\n        try:\n            return VectorValue(self.ux*other,self.uy*other)\n        except Exception:\n            return NotImplemented         \n\n    def __imul__(self,other):\n        return self*other\n\n    def __pow__(self, other):\n        if isinstance(other,int) and other&gt;1:\n            return_value=self*self\n            for i in range(other-2):\n                return_value=return_value*self\n            return return_value\n        else:\n            raise NotImplementedError(\"Operation not supported\")\n\n    # @ (dot product): vector@vector, vector@tensor\n\n    def __matmul__(self,other):\n        if isinstance(other,VectorValue):\n            return self.ux*other.ux+self.uy*other.uy\n        if isinstance(other,TensorValue):\n            return VectorValue(self.ux*other.uxx+self.uy*other.uxy,self.ux*other.uyx+self.uy*other.uyy)\n\n    def __truediv__(self, other):\n        try:\n            return VectorValue(self.ux/other,self.uy/other)\n        except Exception:\n            return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.ux","title":"ux  <code>instance-attribute</code>","text":"<pre><code>ux = ux\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.uy","title":"uy  <code>instance-attribute</code>","text":"<pre><code>uy = uy\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__init__","title":"__init__","text":"<pre><code>__init__(ux, uy) -&gt; None\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __init__(self,ux,uy) -&gt; None:\n    self.ux=ux\n    self.uy=uy\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __str__(self) -&gt; str:\n    return \"({},{})\".format(self.ux,self.uy)\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other,VectorValue):\n        return VectorValue(self.ux+other.ux,self.uy+other.uy)\n    else:\n        try:\n            return VectorValue(self.ux+other,self.uy+other)\n        except Exception:\n            return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __radd__(self, other):\n    return self+other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __iadd__(self,other):\n    return self+other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __sub__(self,other):\n    try:\n        return self+(-1*other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __rsub__(self,other):\n    try:\n        return other+(-1*self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __isub__(self,other):\n    return self-other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __mul__(self,other):\n    if isinstance(other,VectorValue):\n        return TensorValue(self.ux*other.ux,self.ux*other.uy,self.uy*other.ux,self.uy*other.uy)\n    else:\n        try:\n            return VectorValue(self.ux*other,self.uy*other)\n        except Exception:\n            return NotImplemented  \n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __rmul__(self,other):\n    try:\n        return VectorValue(self.ux*other,self.uy*other)\n    except Exception:\n        return NotImplemented         \n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __imul__(self,other):\n    return self*other\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__pow__","title":"__pow__","text":"<pre><code>__pow__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __pow__(self, other):\n    if isinstance(other,int) and other&gt;1:\n        return_value=self*self\n        for i in range(other-2):\n            return_value=return_value*self\n        return return_value\n    else:\n        raise NotImplementedError(\"Operation not supported\")\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__matmul__","title":"__matmul__","text":"<pre><code>__matmul__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __matmul__(self,other):\n    if isinstance(other,VectorValue):\n        return self.ux*other.ux+self.uy*other.uy\n    if isinstance(other,TensorValue):\n        return VectorValue(self.ux*other.uxx+self.uy*other.uxy,self.ux*other.uyx+self.uy*other.uyy)\n</code></pre>"},{"location":"contents/guide/meta/#ConvDO.meta_type.VectorValue.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>ConvDO/meta_type.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return VectorValue(self.ux/other,self.uy/other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"contents/guide/obstacles/","title":"Obstacles","text":""},{"location":"contents/guide/obstacles/#available-boundaries","title":"Available Boundaries","text":"Obstacle Description <code>ConvDO.obstacles.DirichletObstacle</code> The value of the field on the obstacle is fixed at the boundary. <code>ConvDO.obstacles.NeumannObstacle</code> The gradient of the field on the obstacle is fixed at the boundary. <code>ConvDO.obstacles.UnConstrainedObstacle</code> The value of boundary is calculated by the value of the neighbour cells. If you are not sure about the boundary condition on obstacle, you can use <code>UnConstrainedObstacle</code>."},{"location":"contents/guide/obstacles/#calculation-rule-of-obstacles","title":"Calculation Rule of Obstacles","text":"<ul> <li> <p>Dirichlet(a) + Dirichlet(b) = Dirichlet(a+b)</p> </li> <li> <p>Dirichlet(a) * Dirichlet(b) = Dirichlet(a*b)</p> </li> <li> <p>Dirichlet(a) + float(b) = Dirichlet(a+b)</p> </li> <li> <p>Dirichlet(a) * float(b) = Dirichlet(a*b)</p> </li> </ul> <ul> <li> <p>Dirichlet(a) + Neumann(b) = UnConstrained</p> </li> <li> <p>Dirichlet(a) * Neumann(b) = UnConstrained</p> </li> </ul> <ul> <li> <p>Neumann(a) + Neumann(b) = Neumann(a+b)</p> </li> <li> <p>Neumann(a) * Neumann(b) = UnConstrained</p> </li> <li> <p>Neumann(a) + float(b) = Neumann(a)</p> </li> <li> <p>Neumann(a) * float(b) = Neumann(a*b)</p> </li> </ul> <ul> <li> <p>UnConstrained + Other = UnConstrained</p> </li> <li> <p>UnConstrained * Other = UnConstrained</p> </li> </ul>"},{"location":"contents/guide/operations/","title":"Operations","text":""},{"location":"contents/guide/operations/#general-operations","title":"General Operations","text":"<p>Operations are combination of residual operators for given PDEs.</p> <p>A operation can be designed with inheriting the <code>FieldOperations</code> class which provide all the available operators:</p>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations","title":"ConvDO.operations.FieldOperations","text":"<p>A class that performs various operations on fields.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the operations.</p> required <code>device</code> <code>str</code> <p>The device to perform the operations on. Defaults to \"cpu\".</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type of the operations. Defaults to torch.float32.</p> <code>float32</code> <p>Attributes:</p> Name Type Description <code>nabla</code> <code>ConvNabla</code> <p>The gradient operator.</p> <code>nabla2</code> <code>ConvLaplacian</code> <p>The Laplacian operator.</p> <code>grad_x</code> <code>ConvGrad</code> <p>The gradient operator in the x direction.</p> <code>grad_y</code> <code>ConvGrad</code> <p>The gradient operator in the y direction.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>class FieldOperations():\n    r\"\"\"\n    A class that performs various operations on fields.\n\n    Args:\n        order (int): The order of the operations.\n        device (str, optional): The device to perform the operations on. Defaults to \"cpu\".\n        dtype (torch.dtype, optional): The data type of the operations. Defaults to torch.float32.\n\n    Attributes:\n        nabla (ConvNabla): The gradient operator.\n        nabla2 (ConvLaplacian): The Laplacian operator.\n        grad_x (ConvGrad): The gradient operator in the x direction.\n        grad_y (ConvGrad): The gradient operator in the y direction.\n    \"\"\"\n\n    def __init__(self, order:int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n        self.nabla = ConvNabla(order, device=device, dtype=dtype)\n        self.nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n        self.grad_x = ConvGrad(order, direction='x', device=device, dtype=dtype)\n        self.grad_y = ConvGrad(order, direction='y', device=device, dtype=dtype)\n        self.grad2_x = ConvGrad2(order, direction='x', device=device, dtype=dtype)\n        self.grad2_y = ConvGrad2(order, direction='y', device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.FieldOperations.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int, device=\"cpu\", dtype=torch.float32\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, order:int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n    self.nabla = ConvNabla(order, device=device, dtype=dtype)\n    self.nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n    self.grad_x = ConvGrad(order, direction='x', device=device, dtype=dtype)\n    self.grad_y = ConvGrad(order, direction='y', device=device, dtype=dtype)\n    self.grad2_x = ConvGrad2(order, direction='x', device=device, dtype=dtype)\n    self.grad2_y = ConvGrad2(order, direction='y', device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#pre-defined-operations","title":"Pre-defined Operations","text":"<p>We also give some pre-defined operations which mainly focus on the flow dynamics:</p>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS","title":"ConvDO.operations.TransientNS","text":"<p>               Bases: <code>FieldOperations</code></p> <p>Class representing the transient Navier-Stokes equations.     Returns a three channel tensor containing the residual of momentum equation in x and y directions and the divergence of the velocity field.     Defining \\(\\mathbf{u}_{int}=(\\mathbf{u}_0+\\mathbf{u}_1)/2=((u_{x,0}+u_{x,1})/2,(u_{y,0}+u_{y,1})/2)\\), the residual is given by:     \\(\\begin{matrix}\\frac{\\mathbf{u}_1-\\mathbf{u}_0}{\\Delta t}+\\mathbf{u}_{int}\\cdot\\nabla\\mathbf{u}_{int}+\\nabla\\left(\\frac{p_0+p_1}{2}\\right)-\\nu\\nabla^2\\mathbf{u}_{int}\\\\(\\nabla\\cdot\\mathbf{u}_{int}+\\nabla\\cdot\\mathbf{u}_1)/2\\end{matrix}\\)</p> <p>Parameters:</p> Name Type Description Default <code>domain_u</code> <code>Domain</code> <p>The domain for the x-velocity component.</p> required <code>domain_v</code> <code>Domain</code> <p>The domain for the y-velocity component.</p> required <code>domain_p</code> <code>Domain</code> <p>The domain for the pressure component.</p> required <code>viscosity</code> <code>float</code> <p>The viscosity coefficient.</p> required <code>dt</code> <code>float</code> <p>The time step size.</p> required <code>order</code> <code>int</code> <p>The order of accuracy for the finite difference scheme.</p> required <code>device</code> <code>str</code> <p>The device to use for computation (default: \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default: torch.float32).</p> <code>float32</code> Source code in <code>ConvDO/operations.py</code> <pre><code>class TransientNS(FieldOperations):\n    r\"\"\"\n    Class representing the transient Navier-Stokes equations.\n        Returns a three channel tensor containing the residual of momentum equation in x and y directions and the divergence of the velocity field.\n        Defining $\\mathbf{u}_{int}=(\\mathbf{u}_0+\\mathbf{u}_1)/2=((u_{x,0}+u_{x,1})/2,(u_{y,0}+u_{y,1})/2)$, the residual is given by:\n        $\\begin{matrix}\\frac{\\mathbf{u}_1-\\mathbf{u}_0}{\\Delta t}+\\mathbf{u}_{int}\\cdot\\nabla\\mathbf{u}_{int}+\\nabla\\left(\\frac{p_0+p_1}{2}\\right)-\\nu\\nabla^2\\mathbf{u}_{int}\\\\(\\nabla\\cdot\\mathbf{u}_{int}+\\nabla\\cdot\\mathbf{u}_1)/2\\end{matrix}$\n\n    Args:\n        domain_u (Domain): The domain for the x-velocity component.\n        domain_v (Domain): The domain for the y-velocity component.\n        domain_p (Domain): The domain for the pressure component.\n        viscosity (float): The viscosity coefficient.\n        dt (float): The time step size.\n        order (int): The order of accuracy for the finite difference scheme.\n        device (str, optional): The device to use for computation (default: \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default: torch.float32).\n    \"\"\"\n\n    def __init__(self, \n                 domain_u: Domain,\n                 domain_v: Domain, \n                 domain_p: Domain, \n                 viscosity: float, \n                 dt: float,\n                 order:int,\n                 device=\"cpu\", \n                 dtype=torch.float32,\n                 ) -&gt; None:\n        super().__init__(order, device=device, dtype=dtype)\n        self.p_0 = ScalarField(domain=domain_p)\n        self.p_1 = ScalarField(domain=domain_p)\n        self.velocity_0 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n        self.velocity_1 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n        self.viscosity = viscosity\n        self.dt = dt\n\n\n    def __call__(self, u_0, v_0, p_0, u_1, v_1, p_1):\n        \"\"\"\n        Compute the solution of the transient Navier-Stokes equations with external force.\n\n        Args:\n            u_0 (torch.Tensor): The x-velocity component at time step t.\n            v_0 (torch.Tensor): The y-velocity component at time step t.\n            p_0 (torch.Tensor): The pressure component at time step t.\n            u_1 (torch.Tensor): The x-velocity component at time step t+1.\n            v_1 (torch.Tensor): The y-velocity component at time step t+1.\n            p_1 (torch.Tensor): The pressure component at time step t+1.\n\n        Returns:\n            residual (torch.Tensor): The concatenated tensor of the x-velocity, y-velocity, and divergence components.\n        \"\"\"\n        self.velocity_0.ux.register_value(u_0)\n        self.velocity_0.uy.register_value(v_0)\n        self.p_0.register_value(p_0)\n        self.velocity_1.ux.register_value(u_1)\n        self.velocity_1.uy.register_value(v_1)\n        self.p_1.register_value(p_1)\n        u_inter = (self.velocity_0 + self.velocity_1) * 0.5\n        transient = (self.velocity_1 - self.velocity_0) / self.dt\n        advection = u_inter @ (self.nabla * u_inter)\n        pressure = self.nabla * ((self.p_0 + self.p_1) * 0.5)\n        vis = -1 * self.viscosity * (self.nabla2 * u_inter)\n        ns_res = transient + advection + pressure + vis\n        divergence = ((self.nabla @ u_inter) + (self.nabla @ self.velocity_1)) * 0.5\n        return torch.cat([ns_res.ux.value, ns_res.uy.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.p_0","title":"p_0  <code>instance-attribute</code>","text":"<pre><code>p_0 = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.p_1","title":"p_1  <code>instance-attribute</code>","text":"<pre><code>p_1 = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.velocity_0","title":"velocity_0  <code>instance-attribute</code>","text":"<pre><code>velocity_0 = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.velocity_1","title":"velocity_1  <code>instance-attribute</code>","text":"<pre><code>velocity_1 = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.viscosity","title":"viscosity  <code>instance-attribute</code>","text":"<pre><code>viscosity = viscosity\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_u: Domain,\n    domain_v: Domain,\n    domain_p: Domain,\n    viscosity: float,\n    dt: float,\n    order: int,\n    device=\"cpu\",\n    dtype=torch.float32,\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, \n             domain_u: Domain,\n             domain_v: Domain, \n             domain_p: Domain, \n             viscosity: float, \n             dt: float,\n             order:int,\n             device=\"cpu\", \n             dtype=torch.float32,\n             ) -&gt; None:\n    super().__init__(order, device=device, dtype=dtype)\n    self.p_0 = ScalarField(domain=domain_p)\n    self.p_1 = ScalarField(domain=domain_p)\n    self.velocity_0 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n    self.velocity_1 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n    self.viscosity = viscosity\n    self.dt = dt\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNS.__call__","title":"__call__","text":"<pre><code>__call__(u_0, v_0, p_0, u_1, v_1, p_1)\n</code></pre> <p>Compute the solution of the transient Navier-Stokes equations with external force.</p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Tensor</code> <p>The x-velocity component at time step t.</p> required <code>v_0</code> <code>Tensor</code> <p>The y-velocity component at time step t.</p> required <code>p_0</code> <code>Tensor</code> <p>The pressure component at time step t.</p> required <code>u_1</code> <code>Tensor</code> <p>The x-velocity component at time step t+1.</p> required <code>v_1</code> <code>Tensor</code> <p>The y-velocity component at time step t+1.</p> required <code>p_1</code> <code>Tensor</code> <p>The pressure component at time step t+1.</p> required <p>Returns:</p> Name Type Description <code>residual</code> <code>Tensor</code> <p>The concatenated tensor of the x-velocity, y-velocity, and divergence components.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>def __call__(self, u_0, v_0, p_0, u_1, v_1, p_1):\n    \"\"\"\n    Compute the solution of the transient Navier-Stokes equations with external force.\n\n    Args:\n        u_0 (torch.Tensor): The x-velocity component at time step t.\n        v_0 (torch.Tensor): The y-velocity component at time step t.\n        p_0 (torch.Tensor): The pressure component at time step t.\n        u_1 (torch.Tensor): The x-velocity component at time step t+1.\n        v_1 (torch.Tensor): The y-velocity component at time step t+1.\n        p_1 (torch.Tensor): The pressure component at time step t+1.\n\n    Returns:\n        residual (torch.Tensor): The concatenated tensor of the x-velocity, y-velocity, and divergence components.\n    \"\"\"\n    self.velocity_0.ux.register_value(u_0)\n    self.velocity_0.uy.register_value(v_0)\n    self.p_0.register_value(p_0)\n    self.velocity_1.ux.register_value(u_1)\n    self.velocity_1.uy.register_value(v_1)\n    self.p_1.register_value(p_1)\n    u_inter = (self.velocity_0 + self.velocity_1) * 0.5\n    transient = (self.velocity_1 - self.velocity_0) / self.dt\n    advection = u_inter @ (self.nabla * u_inter)\n    pressure = self.nabla * ((self.p_0 + self.p_1) * 0.5)\n    vis = -1 * self.viscosity * (self.nabla2 * u_inter)\n    ns_res = transient + advection + pressure + vis\n    divergence = ((self.nabla @ u_inter) + (self.nabla @ self.velocity_1)) * 0.5\n    return torch.cat([ns_res.ux.value, ns_res.uy.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce","title":"ConvDO.operations.TransientNSWithForce","text":"<p>               Bases: <code>FieldOperations</code></p> <p>Class representing the transient Navier-Stokes equations with external force.     Returns a three channel tensor containing the residual of momentum equation in x and y directions and the divergence of the velocity field.      Defining \\(\\mathbf{u}_{int}=(\\mathbf{u}_0+\\mathbf{u}_1)/2=((u_{x,0}+u_{x,1})/2,(u_{y,0}+u_{y,1})/2)\\), the residual is given by:     \\(\\begin{matrix}\\frac{\\mathbf{u}_1-\\mathbf{u}_0}{\\Delta t}+\\mathbf{u}_{int}\\cdot\\nabla\\mathbf{u}_{int}+\\nabla\\left(\\frac{p_0+p_1}{2}\\right)-\\nu\\nabla^2\\mathbf{u}_{int}-\\mathbf{f}\\\\(\\nabla\\cdot\\mathbf{u}_{int}+\\nabla\\cdot\\mathbf{u}_1)/2\\end{matrix}\\)</p> <p>Parameters:</p> Name Type Description Default <code>domain_u</code> <code>Domain</code> <p>The domain for the x-velocity component.</p> required <code>domain_v</code> <code>Domain</code> <p>The domain for the y-velocity component.</p> required <code>domain_p</code> <code>Domain</code> <p>The domain for the pressure component.</p> required <code>force_x</code> <code>Tensor</code> <p>The x-component of the external force.</p> required <code>force_y</code> <code>Tensor</code> <p>The y-component of the external force.</p> required <code>domain_force_x</code> <code>Domain</code> <p>The domain for the x-component of the external force.</p> required <code>domain_force_y</code> <code>Domain</code> <p>The domain for the y-component of the external force.</p> required <code>viscosity</code> <code>float</code> <p>The viscosity coefficient.</p> required <code>dt</code> <code>float</code> <p>The time step size.</p> required <code>order</code> <code>int</code> <p>The order of accuracy for the finite difference scheme.</p> required <code>device</code> <code>str</code> <p>The device to use for computation (default: \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default: torch.float32).</p> <code>float32</code> Source code in <code>ConvDO/operations.py</code> <pre><code>class TransientNSWithForce(FieldOperations):\n    r\"\"\"\n    Class representing the transient Navier-Stokes equations with external force.\n        Returns a three channel tensor containing the residual of momentum equation in x and y directions and the divergence of the velocity field.   \n        Defining $\\mathbf{u}_{int}=(\\mathbf{u}_0+\\mathbf{u}_1)/2=((u_{x,0}+u_{x,1})/2,(u_{y,0}+u_{y,1})/2)$, the residual is given by:\n        $\\begin{matrix}\\frac{\\mathbf{u}_1-\\mathbf{u}_0}{\\Delta t}+\\mathbf{u}_{int}\\cdot\\nabla\\mathbf{u}_{int}+\\nabla\\left(\\frac{p_0+p_1}{2}\\right)-\\nu\\nabla^2\\mathbf{u}_{int}-\\mathbf{f}\\\\(\\nabla\\cdot\\mathbf{u}_{int}+\\nabla\\cdot\\mathbf{u}_1)/2\\end{matrix}$\n\n\n    Args:\n        domain_u (Domain): The domain for the x-velocity component.\n        domain_v (Domain): The domain for the y-velocity component.\n        domain_p (Domain): The domain for the pressure component.\n        force_x (torch.Tensor): The x-component of the external force.\n        force_y (torch.Tensor): The y-component of the external force.\n        domain_force_x (Domain): The domain for the x-component of the external force.\n        domain_force_y (Domain): The domain for the y-component of the external force.\n        viscosity (float): The viscosity coefficient.\n        dt (float): The time step size.\n        order (int): The order of accuracy for the finite difference scheme.\n        device (str, optional): The device to use for computation (default: \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default: torch.float32).\n    \"\"\"\n\n    def __init__(self, \n                 domain_u: Domain,\n                 domain_v: Domain, \n                 domain_p: Domain, \n                 force_x: torch.Tensor,\n                 force_y: torch.Tensor,\n                 domain_force_x: Domain, \n                 domain_force_y: Domain, \n                 viscosity: float, \n                 dt: float,\n                 order:int,\n                 device=\"cpu\", \n                 dtype=torch.float32,\n                 ) -&gt; None:\n        super().__init__(order, device=device, dtype=dtype)\n        self.p_0 = ScalarField(domain=domain_p)\n        self.p_1 = ScalarField(domain=domain_p)\n        self.velocity_0 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n        self.velocity_1 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n        self.force = VectorValue(ScalarField(force_x, domain=domain_force_x),\n                                 ScalarField(force_y, domain=domain_force_y))\n        self.viscosity = viscosity\n        self.dt = dt\n\n\n    def __call__(self, u_0, v_0, p_0, u_1, v_1, p_1):\n        \"\"\"\n        Compute the solution of the transient Navier-Stokes equations with external force.\n\n        Args:\n            u_0 (torch.Tensor): The x-velocity component at time step t.\n            v_0 (torch.Tensor): The y-velocity component at time step t.\n            p_0 (torch.Tensor): The pressure component at time step t.\n            u_1 (torch.Tensor): The x-velocity component at time step t+1.\n            v_1 (torch.Tensor): The y-velocity component at time step t+1.\n            p_1 (torch.Tensor): The pressure component at time step t+1.\n\n        Returns:\n            residual (torch.Tensor): The concatenated tensor of the x-velocity, y-velocity, and divergence components.\n        \"\"\"\n        self.velocity_0.ux.register_value(u_0)\n        self.velocity_0.uy.register_value(v_0)\n        self.p_0.register_value(p_0)\n        self.velocity_1.ux.register_value(u_1)\n        self.velocity_1.uy.register_value(v_1)\n        self.p_1.register_value(p_1)\n        u_inter = (self.velocity_0 + self.velocity_1) * 0.5\n        transient = (self.velocity_1 - self.velocity_0) / self.dt\n        advection = u_inter @ (self.nabla * u_inter)\n        pressure = self.nabla * ((self.p_0 + self.p_1) * 0.5)\n        vis = -1 * self.viscosity * (self.nabla2 * u_inter)\n        ns_res = transient + advection + pressure + vis - self.force\n        divergence = ((self.nabla @ u_inter) + (self.nabla @ self.velocity_1)) * 0.5\n        return torch.cat([ns_res.ux.value, ns_res.uy.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.p_0","title":"p_0  <code>instance-attribute</code>","text":"<pre><code>p_0 = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.p_1","title":"p_1  <code>instance-attribute</code>","text":"<pre><code>p_1 = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.velocity_0","title":"velocity_0  <code>instance-attribute</code>","text":"<pre><code>velocity_0 = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.velocity_1","title":"velocity_1  <code>instance-attribute</code>","text":"<pre><code>velocity_1 = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.force","title":"force  <code>instance-attribute</code>","text":"<pre><code>force = VectorValue(\n    ScalarField(force_x, domain=domain_force_x),\n    ScalarField(force_y, domain=domain_force_y),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.viscosity","title":"viscosity  <code>instance-attribute</code>","text":"<pre><code>viscosity = viscosity\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_u: Domain,\n    domain_v: Domain,\n    domain_p: Domain,\n    force_x: torch.Tensor,\n    force_y: torch.Tensor,\n    domain_force_x: Domain,\n    domain_force_y: Domain,\n    viscosity: float,\n    dt: float,\n    order: int,\n    device=\"cpu\",\n    dtype=torch.float32,\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, \n             domain_u: Domain,\n             domain_v: Domain, \n             domain_p: Domain, \n             force_x: torch.Tensor,\n             force_y: torch.Tensor,\n             domain_force_x: Domain, \n             domain_force_y: Domain, \n             viscosity: float, \n             dt: float,\n             order:int,\n             device=\"cpu\", \n             dtype=torch.float32,\n             ) -&gt; None:\n    super().__init__(order, device=device, dtype=dtype)\n    self.p_0 = ScalarField(domain=domain_p)\n    self.p_1 = ScalarField(domain=domain_p)\n    self.velocity_0 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n    self.velocity_1 = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n    self.force = VectorValue(ScalarField(force_x, domain=domain_force_x),\n                             ScalarField(force_y, domain=domain_force_y))\n    self.viscosity = viscosity\n    self.dt = dt\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.TransientNSWithForce.__call__","title":"__call__","text":"<pre><code>__call__(u_0, v_0, p_0, u_1, v_1, p_1)\n</code></pre> <p>Compute the solution of the transient Navier-Stokes equations with external force.</p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Tensor</code> <p>The x-velocity component at time step t.</p> required <code>v_0</code> <code>Tensor</code> <p>The y-velocity component at time step t.</p> required <code>p_0</code> <code>Tensor</code> <p>The pressure component at time step t.</p> required <code>u_1</code> <code>Tensor</code> <p>The x-velocity component at time step t+1.</p> required <code>v_1</code> <code>Tensor</code> <p>The y-velocity component at time step t+1.</p> required <code>p_1</code> <code>Tensor</code> <p>The pressure component at time step t+1.</p> required <p>Returns:</p> Name Type Description <code>residual</code> <code>Tensor</code> <p>The concatenated tensor of the x-velocity, y-velocity, and divergence components.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>def __call__(self, u_0, v_0, p_0, u_1, v_1, p_1):\n    \"\"\"\n    Compute the solution of the transient Navier-Stokes equations with external force.\n\n    Args:\n        u_0 (torch.Tensor): The x-velocity component at time step t.\n        v_0 (torch.Tensor): The y-velocity component at time step t.\n        p_0 (torch.Tensor): The pressure component at time step t.\n        u_1 (torch.Tensor): The x-velocity component at time step t+1.\n        v_1 (torch.Tensor): The y-velocity component at time step t+1.\n        p_1 (torch.Tensor): The pressure component at time step t+1.\n\n    Returns:\n        residual (torch.Tensor): The concatenated tensor of the x-velocity, y-velocity, and divergence components.\n    \"\"\"\n    self.velocity_0.ux.register_value(u_0)\n    self.velocity_0.uy.register_value(v_0)\n    self.p_0.register_value(p_0)\n    self.velocity_1.ux.register_value(u_1)\n    self.velocity_1.uy.register_value(v_1)\n    self.p_1.register_value(p_1)\n    u_inter = (self.velocity_0 + self.velocity_1) * 0.5\n    transient = (self.velocity_1 - self.velocity_0) / self.dt\n    advection = u_inter @ (self.nabla * u_inter)\n    pressure = self.nabla * ((self.p_0 + self.p_1) * 0.5)\n    vis = -1 * self.viscosity * (self.nabla2 * u_inter)\n    ns_res = transient + advection + pressure + vis - self.force\n    divergence = ((self.nabla @ u_inter) + (self.nabla @ self.velocity_1)) * 0.5\n    return torch.cat([ns_res.ux.value, ns_res.uy.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence","title":"ConvDO.operations.PoissonDivergence","text":"<p>               Bases: <code>FieldOperations</code></p> <p>Class representing the Poisson equation for pressure and the divergence of the velocity field.     Returns a two channel tensor containing the residual of the Poisson equation and the divergence of the velocity field.     Residual of Poisson equation:\\(\\left( {{\\partial^2 p} \\over {\\partial x^2}} + {{\\partial^2 p} \\over {\\partial y^2}} \\right) = \\left( {{\\partial u} \\over {\\partial x}} \\right)^2 + 2 {{\\partial u} \\over {\\partial y}} {{\\partial v} \\over {\\partial x}}+ \\left( {{\\partial v} \\over {\\partial y}} \\right)^2\\)     Residual of continuity:\\(\\nabla\\cdot\\mathbf{u}\\)</p> <p>Parameters:</p> Name Type Description Default <code>domain_u</code> <code>Domain</code> <p>The domain for the x-velocity component.</p> required <code>domain_v</code> <code>Domain</code> <p>The domain for the y-velocity component.</p> required <code>domain_p</code> <code>Domain</code> <p>The domain for the pressure component.</p> required <code>order</code> <code>int</code> <p>The order of accuracy for the finite difference scheme.</p> required <code>device</code> <code>str</code> <p>The device to use for computation (default: \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default: torch.float32).</p> <code>float32</code> Source code in <code>ConvDO/operations.py</code> <pre><code>class PoissonDivergence(FieldOperations):\n    r\"\"\"\n    Class representing the Poisson equation for pressure and the divergence of the velocity field.\n        Returns a two channel tensor containing the residual of the Poisson equation and the divergence of the velocity field.\n        Residual of Poisson equation:$\\left( {{\\partial^2 p} \\over {\\partial x^2}} + {{\\partial^2 p} \\over {\\partial y^2}} \\right) = \\left( {{\\partial u} \\over {\\partial x}} \\right)^2 + 2 {{\\partial u} \\over {\\partial y}} {{\\partial v} \\over {\\partial x}}+ \\left( {{\\partial v} \\over {\\partial y}} \\right)^2$\n        Residual of continuity:$\\nabla\\cdot\\mathbf{u}$\n\n    Args:\n        domain_u (Domain): The domain for the x-velocity component.\n        domain_v (Domain): The domain for the y-velocity component.\n        domain_p (Domain): The domain for the pressure component.\n        order (int): The order of accuracy for the finite difference scheme.\n        device (str, optional): The device to use for computation (default: \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default: torch.float32).\n    \"\"\"\n\n    def __init__(self, \n                 domain_u: Domain,\n                 domain_v: Domain, \n                 domain_p: Domain, \n                 order: int,\n                 device=\"cpu\", \n                 dtype=torch.float32) -&gt; None:\n        super().__init__(order, device=device, dtype=dtype)\n        self.pressure = ScalarField(domain=domain_p)\n        self.velocity = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n\n    def __call__(self, u, v, p):\n        \"\"\"\n        Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.\n\n        Args:\n            u (torch.Tensor): The x-velocity component.\n            v (torch.Tensor): The y-velocity component.\n            p (torch.Tensor): The pressure component.\n\n        Returns:\n            residual (torch.Tensor): The concatenated tensor of the Poisson equation and the divergence components.\n        \"\"\"\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        self.pressure.register_value(p)\n        poisson = (self.nabla2*self.pressure)+(self.grad_x*self.velocity.ux)**2+2*(self.grad_y*self.velocity.ux)*(self.grad_x*self.velocity.uy)+(self.grad_y*self.velocity.uy)**2\n        divergence = self.nabla@self.velocity\n        return torch.cat([poisson.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.pressure","title":"pressure  <code>instance-attribute</code>","text":"<pre><code>pressure = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.velocity","title":"velocity  <code>instance-attribute</code>","text":"<pre><code>velocity = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_u: Domain,\n    domain_v: Domain,\n    domain_p: Domain,\n    order: int,\n    device=\"cpu\",\n    dtype=torch.float32,\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, \n             domain_u: Domain,\n             domain_v: Domain, \n             domain_p: Domain, \n             order: int,\n             device=\"cpu\", \n             dtype=torch.float32) -&gt; None:\n    super().__init__(order, device=device, dtype=dtype)\n    self.pressure = ScalarField(domain=domain_p)\n    self.velocity = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergence.__call__","title":"__call__","text":"<pre><code>__call__(u, v, p)\n</code></pre> <p>Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Tensor</code> <p>The x-velocity component.</p> required <code>v</code> <code>Tensor</code> <p>The y-velocity component.</p> required <code>p</code> <code>Tensor</code> <p>The pressure component.</p> required <p>Returns:</p> Name Type Description <code>residual</code> <code>Tensor</code> <p>The concatenated tensor of the Poisson equation and the divergence components.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>def __call__(self, u, v, p):\n    \"\"\"\n    Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.\n\n    Args:\n        u (torch.Tensor): The x-velocity component.\n        v (torch.Tensor): The y-velocity component.\n        p (torch.Tensor): The pressure component.\n\n    Returns:\n        residual (torch.Tensor): The concatenated tensor of the Poisson equation and the divergence components.\n    \"\"\"\n    self.velocity.ux.register_value(u)\n    self.velocity.uy.register_value(v)\n    self.pressure.register_value(p)\n    poisson = (self.nabla2*self.pressure)+(self.grad_x*self.velocity.ux)**2+2*(self.grad_y*self.velocity.ux)*(self.grad_x*self.velocity.uy)+(self.grad_y*self.velocity.uy)**2\n    divergence = self.nabla@self.velocity\n    return torch.cat([poisson.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce","title":"ConvDO.operations.PoissonDivergenceWithForce","text":"<p>               Bases: <code>FieldOperations</code></p> <p>Class representing the Poisson equation for pressure and the divergence of the velocity field.     Returns a two channel tensor containing the residual of the Poisson equation and the divergence of the velocity field.     Residual of Poisson equation:     \\(\\left( {{\\partial^2 p} \\over {\\partial x^2}} + {{\\partial^2 p} \\over {\\partial y^2}} \\right) = \\left( {{\\partial u} \\over {\\partial x}} \\right)^2 + 2 {{\\partial u} \\over {\\partial y}} {{\\partial v} \\over {\\partial x}}+ \\left( {{\\partial v} \\over {\\partial y}} \\right)^2\\)     Residual of continuity:\\(\\nabla\\cdot\\mathbf{u}\\)</p> <p>Parameters:</p> Name Type Description Default <code>domain_u</code> <code>Domain</code> <p>The domain for the x-velocity component.</p> required <code>domain_v</code> <code>Domain</code> <p>The domain for the y-velocity component.</p> required <code>domain_p</code> <code>Domain</code> <p>The domain for the pressure component.</p> required <code>force_x</code> <code>Tensor</code> <p>The x-component of the external force.</p> required <code>force_y</code> <code>Tensor</code> <p>The y-component of the external force.</p> required <code>domain_force_x</code> <code>Domain</code> <p>The domain for the x-component of the external force.</p> required <code>domain_force_y</code> <code>Domain</code> <p>The domain for the y-component of the external force.</p> required <code>order</code> <code>int</code> <p>The order of accuracy for the finite difference scheme.</p> required <code>device</code> <code>str</code> <p>The device to use for computation (default: \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default: torch.float32).</p> <code>float32</code> Source code in <code>ConvDO/operations.py</code> <pre><code>class PoissonDivergenceWithForce(FieldOperations):\n    r\"\"\"\n    Class representing the Poisson equation for pressure and the divergence of the velocity field.\n        Returns a two channel tensor containing the residual of the Poisson equation and the divergence of the velocity field.\n        Residual of Poisson equation:\n        $\\left( {{\\partial^2 p} \\over {\\partial x^2}} + {{\\partial^2 p} \\over {\\partial y^2}} \\right) = \\left( {{\\partial u} \\over {\\partial x}} \\right)^2 + 2 {{\\partial u} \\over {\\partial y}} {{\\partial v} \\over {\\partial x}}+ \\left( {{\\partial v} \\over {\\partial y}} \\right)^2$\n        Residual of continuity:$\\nabla\\cdot\\mathbf{u}$\n\n    Args:\n        domain_u (Domain): The domain for the x-velocity component.\n        domain_v (Domain): The domain for the y-velocity component.\n        domain_p (Domain): The domain for the pressure component.\n        force_x (torch.Tensor): The x-component of the external force.\n        force_y (torch.Tensor): The y-component of the external force.\n        domain_force_x (Domain): The domain for the x-component of the external force.\n        domain_force_y (Domain): The domain for the y-component of the external force.\n        order (int): The order of accuracy for the finite difference scheme.\n        device (str, optional): The device to use for computation (default: \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default: torch.float32).\n    \"\"\"\n\n    def __init__(self, \n                 domain_u: Domain,\n                 domain_v: Domain, \n                 domain_p: Domain, \n                 force_x: torch.Tensor,\n                 force_y: torch.Tensor,\n                 domain_force_x: Domain, \n                 domain_force_y: Domain,\n                 order: int,\n                 device=\"cpu\", \n                 dtype=torch.float32) -&gt; None:\n        super().__init__(order, device=device, dtype=dtype)\n        self.pressure = ScalarField(domain=domain_p)\n        self.velocity = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n        self.force = VectorValue(ScalarField(force_x, domain=domain_force_x),ScalarField(force_y, domain=domain_force_y))\n\n    def __call__(self, u, v, p):\n        \"\"\"\n        Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.\n\n        Args:\n            u (torch.Tensor): The x-velocity component.\n            v (torch.Tensor): The y-velocity component.\n            p (torch.Tensor): The pressure component.\n\n        Returns:\n            residual (torch.Tensor): The concatenated tensor of the Poisson equation and the divergence components.\n        \"\"\"\n        self.velocity.ux.register_value(u)\n        self.velocity.uy.register_value(v)\n        self.pressure.register_value(p)\n        poisson = (self.nabla2*self.pressure)+(self.grad_x*self.velocity.ux)**2+2*(self.grad_y*self.velocity.ux)*(self.grad_x*self.velocity.uy)+(self.grad_y*self.velocity.uy)**2-self.nabla@self.force\n        divergence = self.nabla@self.velocity\n        return torch.cat([poisson.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.nabla","title":"nabla  <code>instance-attribute</code>","text":"<pre><code>nabla = ConvNabla(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.nabla2","title":"nabla2  <code>instance-attribute</code>","text":"<pre><code>nabla2 = ConvLaplacian(order, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.grad_x","title":"grad_x  <code>instance-attribute</code>","text":"<pre><code>grad_x = ConvGrad(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.grad_y","title":"grad_y  <code>instance-attribute</code>","text":"<pre><code>grad_y = ConvGrad(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.grad2_x","title":"grad2_x  <code>instance-attribute</code>","text":"<pre><code>grad2_x = ConvGrad2(\n    order, direction=\"x\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.grad2_y","title":"grad2_y  <code>instance-attribute</code>","text":"<pre><code>grad2_y = ConvGrad2(\n    order, direction=\"y\", device=device, dtype=dtype\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.pressure","title":"pressure  <code>instance-attribute</code>","text":"<pre><code>pressure = ScalarField(domain=domain_p)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.velocity","title":"velocity  <code>instance-attribute</code>","text":"<pre><code>velocity = VectorValue(\n    ScalarField(domain=domain_u),\n    ScalarField(domain=domain_v),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.force","title":"force  <code>instance-attribute</code>","text":"<pre><code>force = VectorValue(\n    ScalarField(force_x, domain=domain_force_x),\n    ScalarField(force_y, domain=domain_force_y),\n)\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.__init__","title":"__init__","text":"<pre><code>__init__(\n    domain_u: Domain,\n    domain_v: Domain,\n    domain_p: Domain,\n    force_x: torch.Tensor,\n    force_y: torch.Tensor,\n    domain_force_x: Domain,\n    domain_force_y: Domain,\n    order: int,\n    device=\"cpu\",\n    dtype=torch.float32,\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/operations.py</code> <pre><code>def __init__(self, \n             domain_u: Domain,\n             domain_v: Domain, \n             domain_p: Domain, \n             force_x: torch.Tensor,\n             force_y: torch.Tensor,\n             domain_force_x: Domain, \n             domain_force_y: Domain,\n             order: int,\n             device=\"cpu\", \n             dtype=torch.float32) -&gt; None:\n    super().__init__(order, device=device, dtype=dtype)\n    self.pressure = ScalarField(domain=domain_p)\n    self.velocity = VectorValue(ScalarField(domain=domain_u), ScalarField(domain=domain_v))\n    self.force = VectorValue(ScalarField(force_x, domain=domain_force_x),ScalarField(force_y, domain=domain_force_y))\n</code></pre>"},{"location":"contents/guide/operations/#ConvDO.operations.PoissonDivergenceWithForce.__call__","title":"__call__","text":"<pre><code>__call__(u, v, p)\n</code></pre> <p>Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Tensor</code> <p>The x-velocity component.</p> required <code>v</code> <code>Tensor</code> <p>The y-velocity component.</p> required <code>p</code> <code>Tensor</code> <p>The pressure component.</p> required <p>Returns:</p> Name Type Description <code>residual</code> <code>Tensor</code> <p>The concatenated tensor of the Poisson equation and the divergence components.</p> Source code in <code>ConvDO/operations.py</code> <pre><code>def __call__(self, u, v, p):\n    \"\"\"\n    Compute the solution of the Poisson equation for pressure and the divergence of the velocity field.\n\n    Args:\n        u (torch.Tensor): The x-velocity component.\n        v (torch.Tensor): The y-velocity component.\n        p (torch.Tensor): The pressure component.\n\n    Returns:\n        residual (torch.Tensor): The concatenated tensor of the Poisson equation and the divergence components.\n    \"\"\"\n    self.velocity.ux.register_value(u)\n    self.velocity.uy.register_value(v)\n    self.pressure.register_value(p)\n    poisson = (self.nabla2*self.pressure)+(self.grad_x*self.velocity.ux)**2+2*(self.grad_y*self.velocity.ux)*(self.grad_x*self.velocity.uy)+(self.grad_y*self.velocity.uy)**2-self.nabla@self.force\n    divergence = self.nabla@self.velocity\n    return torch.cat([poisson.value, divergence.value], dim=-3)\n</code></pre>"},{"location":"contents/guide/operators/","title":"Operators","text":""},{"location":"contents/guide/operators/#available-operators","title":"Available Operators","text":"<p>Operators are the core of <code>ConvDO</code>, the spatial derivate with corresponding code representation is listed as follows:</p> Operation Operator initialization Code of operation \\(\\frac{\\partial p }{ \\partial x}\\) <code>grad_x=ConvGrad(direction=\"x\")</code> <code>grad_x * p</code> \\(\\frac{\\partial p }{ \\partial y}\\) <code>grad_x=ConvGrad(direction=\"y\")</code> <code>grad_y * p</code> \\(\\nabla p = (\\frac{\\partial p }{ \\partial p},\\frac{\\partial p }{ \\partial y})\\) <code>nabla=ConvNabla()</code> <code>nabla * p</code> \\(\\nabla \\cdot \\mathbf{u}=\\frac{\\partial u_x }{ \\partial x}+\\frac{\\partial u_y }{ \\partial y}\\) <code>nabla=ConvNabla()</code> <code>nabla @ u</code> \\(\\frac{\\partial^2 p }{ \\partial x^2}\\) <code>grad2_x=ConvGrad2(direction=\"x\")</code> <code>grad2_x * p</code> \\(\\frac{\\partial^2 p }{ \\partial y^2}\\) <code>grad2_x=ConvGrad2(direction=\"y\")</code> <code>grad2_y * p</code> \\(\\nabla^2 p = (\\frac{\\partial^2 p }{ \\partial x^2},\\frac{\\partial^2 p }{ \\partial y^2})\\) <code>nabla2=ConvLaplacian()</code> <code>nabla * p</code> \\(\\nabla \\cdot (\\nabla \\mathbf{u}) = (\\frac{\\partial u_x }{ \\partial x}+\\frac{\\partial u_x }{ \\partial y},\\frac{\\partial u_y }{ \\partial x}+\\frac{\\partial u_y }{ \\partial y})\\) <code>nabla2=ConvLaplacian()</code> <code>nabla * u</code> <p>Note: If you use <code>ConvDO.operations.FieldOperations</code>, the name of the operators is unchanged, e.g., the corresponding operator of <code>grad_x</code> is <code>self.grad_x</code>.</p>"},{"location":"contents/guide/operators/#api-guide-of-operators","title":"API Guide of Operators","text":""},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvGrad","title":"ConvDO.conv_operators.ConvGrad","text":"<pre><code>ConvGrad(\n    order: int = 2,\n    direction: str = \"x\",\n    device=\"cpu\",\n    dtype=torch.float32,\n)\n</code></pre> <p>Gradient operator \\(\\partial / \\partial x\\) or \\(\\partial / \\partial y\\) for a scalar.</p> <p>Examples:</p> <pre><code>p=ScalarField(torch.rand(1,1,10,10))\ngrad_x = ConvGrad(order=2, direction=\"x\", device=\"cpu\", dtype=torch.float32)\ngrad_y = ConvGrad(order=2, direction=\"y\", device=\"cpu\", dtype=torch.float32)\ngrad_x*p # $\\partial p / \\partial x$ \ngrad_y*p # $\\partial p / \\partial y$\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the central interpolation scheme (default is 2).</p> <code>2</code> <code>direction</code> <code>str</code> <p>The direction of the gradient operator, (\"x\" or \"y\", default is \"x\").</p> <code>'x'</code> <code>device</code> <code>str</code> <p>The device to use for computation (default is \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default is torch.float32).</p> <code>float32</code> <p>Returns:</p> Name Type Description <code>ConvOperator</code> <code>ConvOperator</code> <p>The convolutional gradient operator.</p> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def ConvGrad(order: int=2, direction: str=\"x\", device=\"cpu\", dtype=torch.float32):\n    r\"\"\"\n    Gradient operator $\\partial / \\partial x$ or $\\partial / \\partial y$ for a scalar.\n\n    Examples:\n        ```python\n        p=ScalarField(torch.rand(1,1,10,10))\n        grad_x = ConvGrad(order=2, direction=\"x\", device=\"cpu\", dtype=torch.float32)\n        grad_y = ConvGrad(order=2, direction=\"y\", device=\"cpu\", dtype=torch.float32)\n        grad_x*p # $\\partial p / \\partial x$ \n        grad_y*p # $\\partial p / \\partial y$\n        ```\n\n    Args:\n        order (int): The order of the central interpolation scheme (default is 2).\n        direction (str): The direction of the gradient operator, (\"x\" or \"y\", default is \"x\").\n        device (str, optional): The device to use for computation (default is \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default is torch.float32).\n\n    Returns:\n        ConvOperator (ConvOperator): The convolutional gradient operator.\n\n    \"\"\"\n    return ConvOperator(CENTRAL_INTERPOLATION_SCHEMES[order], direction=direction, derivative=1, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvNabla","title":"ConvDO.conv_operators.ConvNabla","text":"<pre><code>ConvNabla(order: int, device='cpu', dtype=torch.float32)\n</code></pre> <p>\\(\\nabla=(\\partial p / \\partial x,\\partial p / \\partial y)\\) operator.  Can be used to compute the gradient of a scalar field or the divergence of a vector field.</p> <p>Examples:</p> <pre><code>Gradient of a scalar field:\n```python\np=ScalarField(torch.rand(1,1,10,10))\nnabla = ConvNabla(order=2, device=\"cpu\", dtype=torch.float32)\nnabla*p # $\\nabla p$\n```\n\nDivergence of a vector field:\n```python\nu=VectorValue(ScalarField(torch.rand(1,1,10,10)),ScalarField(torch.rand(1,1,10,10)))\nnabla = ConvNabla(order=2, device=\"cpu\", dtype=torch.float32)\nnabla@u # $\\nabla \\cdot u$\n```\n</code></pre> <p>Args:     order (int): The order of the central interpolation scheme (default is 2).     device (str, optional): The device to use for computation (default is \"cpu\").     dtype (torch.dtype, optional): The data type to use for computation (default is torch.float32).</p> <p>Returns:</p> Name Type Description <code>ConvOperator</code> <code>ConvOperator</code> <p>The convolutional gradient operator.</p> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def ConvNabla(order: int, device=\"cpu\", dtype=torch.float32):\n    r\"\"\"\n    $\\nabla=(\\partial p / \\partial x,\\partial p / \\partial y)$ operator. \n    Can be used to compute the gradient of a scalar field or the divergence of a vector field.\n\n    Examples:\n\n        Gradient of a scalar field:\n        ```python\n        p=ScalarField(torch.rand(1,1,10,10))\n        nabla = ConvNabla(order=2, device=\"cpu\", dtype=torch.float32)\n        nabla*p # $\\nabla p$\n        ```\n\n        Divergence of a vector field:\n        ```python\n        u=VectorValue(ScalarField(torch.rand(1,1,10,10)),ScalarField(torch.rand(1,1,10,10)))\n        nabla = ConvNabla(order=2, device=\"cpu\", dtype=torch.float32)\n        nabla@u # $\\nabla \\cdot u$\n        ```\n    Args:\n        order (int): The order of the central interpolation scheme (default is 2).\n        device (str, optional): The device to use for computation (default is \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default is torch.float32).\n\n    Returns:\n        ConvOperator (ConvOperator): The convolutional gradient operator.\n    \"\"\"\n    return VectorValue(\n        ConvOperator(CENTRAL_INTERPOLATION_SCHEMES[order], direction='x', derivative=1, device=device, dtype=dtype), \n        ConvOperator(CENTRAL_INTERPOLATION_SCHEMES[order], direction='y', derivative=1, device=device, dtype=dtype)\n        )\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvGrad2","title":"ConvDO.conv_operators.ConvGrad2","text":"<pre><code>ConvGrad2(\n    order: int = 2,\n    direction=\"x\",\n    device=\"cpu\",\n    dtype=torch.float32,\n)\n</code></pre> <p>Second order gradient operator \\(\\partial^2 / \\partial x^2\\) or \\(\\partial^2 / \\partial y^2\\) for a scalar.</p> <p>Examples:</p> <pre><code>p=ScalarField(torch.rand(1,1,10,10))\ngrad_x = ConvGrad2(order=2, direction=\"x\", device=\"cpu\", dtype=torch.float32)\ngrad_y = ConvGrad2(order=2, direction=\"y\", device=\"cpu\", dtype=torch.float32)\ngrad_x*p # $\\partial^2 p / \\partial x^2$ \ngrad_y*p # $\\partial^2 p / \\partial y^2$\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the central Laplacian scheme (default is 2).</p> <code>2</code> <code>direction</code> <code>str</code> <p>The direction of the gradient operator, (\"x\" or \"y\", default is \"x\").</p> <code>'x'</code> <code>device</code> <code>str</code> <p>The device to use for computation (default is \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default is torch.float32).</p> <code>float32</code> <p>Returns:</p> Name Type Description <code>ConvOperator</code> <code>ConvOperator</code> <p>The convolutional gradient operator.</p> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def ConvGrad2(order: int=2, direction=\"x\", device=\"cpu\", dtype=torch.float32):\n    r\"\"\"\n    Second order gradient operator $\\partial^2 / \\partial x^2$ or $\\partial^2 / \\partial y^2$ for a scalar.\n\n    Examples:\n        ```python\n        p=ScalarField(torch.rand(1,1,10,10))\n        grad_x = ConvGrad2(order=2, direction=\"x\", device=\"cpu\", dtype=torch.float32)\n        grad_y = ConvGrad2(order=2, direction=\"y\", device=\"cpu\", dtype=torch.float32)\n        grad_x*p # $\\partial^2 p / \\partial x^2$ \n        grad_y*p # $\\partial^2 p / \\partial y^2$\n        ```\n\n    Args:\n        order (int): The order of the central Laplacian scheme (default is 2).\n        direction (str): The direction of the gradient operator, (\"x\" or \"y\", default is \"x\").\n        device (str, optional): The device to use for computation (default is \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default is torch.float32).\n\n    Returns:\n        ConvOperator (ConvOperator): The convolutional gradient operator.\n    \"\"\"\n    return ConvOperator(CENTRAL_LAPLACIAN_SCHEMES[order], direction=direction, derivative=2, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvLaplacian","title":"ConvDO.conv_operators.ConvLaplacian","text":"<p>Laplacian operator.  For scalar field, it is defined as \\(\\nabla^2 p = \\partial^2 p / \\partial x^2 + \\partial^2 p / \\partial y^2\\). For vector field, it is defined as \\(\\nabla \\cdot (\\nabla \\mathbf{u}) = (\\frac{\\partial u_x }{ \\partial x}+\\frac{\\partial u_x }{ \\partial y},\\frac{\\partial u_y }{ \\partial x}+\\frac{\\partial u_y }{ \\partial y})\\).</p> <p>Examples:</p> <pre><code>Gradient of a scalar field:\n```python\np=ScalarField(torch.rand(1,1,10,10))\nnabla2 = ConvLaplacian(order=2, device=\"cpu\", dtype=torch.float32)\nnabla2*p # $\\nabla^2 p$\n```\n\nDivergence of a vector field:\n```python\nu=VectorValue(ScalarField(torch.rand(1,1,10,10)),ScalarField(torch.rand(1,1,10,10)))\nnabla2 = ConvLaplacian(order=2, device=\"cpu\", dtype=torch.float32)\nnabla*u # $\\nabla \\cdot (\\nabla \\mathbf{u})$\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of the central Laplacian scheme (default is 2).</p> required <code>device</code> <code>str</code> <p>The device to use for computation (default is \"cpu\").</p> <code>'cpu'</code> <code>dtype</code> <code>dtype</code> <p>The data type to use for computation (default is torch.float32).</p> <code>float32</code> <p>Returns:</p> Name Type Description <code>ConvOperator</code> <code>ConvOperator</code> <p>The convolutional gradient operator.</p> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>class ConvLaplacian():\n    r\"\"\"\n    Laplacian operator. \n    For scalar field, it is defined as $\\nabla^2 p = \\partial^2 p / \\partial x^2 + \\partial^2 p / \\partial y^2$.\n    For vector field, it is defined as $\\nabla \\cdot (\\nabla \\mathbf{u}) = (\\frac{\\partial u_x }{ \\partial x}+\\frac{\\partial u_x }{ \\partial y},\\frac{\\partial u_y }{ \\partial x}+\\frac{\\partial u_y }{ \\partial y})$.\n\n    Examples:\n\n        Gradient of a scalar field:\n        ```python\n        p=ScalarField(torch.rand(1,1,10,10))\n        nabla2 = ConvLaplacian(order=2, device=\"cpu\", dtype=torch.float32)\n        nabla2*p # $\\nabla^2 p$\n        ```\n\n        Divergence of a vector field:\n        ```python\n        u=VectorValue(ScalarField(torch.rand(1,1,10,10)),ScalarField(torch.rand(1,1,10,10)))\n        nabla2 = ConvLaplacian(order=2, device=\"cpu\", dtype=torch.float32)\n        nabla*u # $\\nabla \\cdot (\\nabla \\mathbf{u})$\n        ```\n\n    Args:\n        order (int): The order of the central Laplacian scheme (default is 2).\n        device (str, optional): The device to use for computation (default is \"cpu\").\n        dtype (torch.dtype, optional): The data type to use for computation (default is torch.float32).\n\n    Returns:\n        ConvOperator (ConvOperator): The convolutional gradient operator.\n    \"\"\"\n    def __init__(self, order: int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n        self.op_x = ConvOperator(\n            CENTRAL_LAPLACIAN_SCHEMES[order], direction='x', derivative=2, device=device, dtype=dtype)\n        self.op_y = ConvOperator(\n            CENTRAL_LAPLACIAN_SCHEMES[order], direction='y', derivative=2, device=device, dtype=dtype)\n\n    def __mul__(self, other):\n        if isinstance(other, ScalarField):\n            return self.op_x*other+self.op_y*other\n        elif isinstance(other, VectorValue):\n            return VectorValue(\n                self.op_x*other.ux+self.op_y*other.ux,\n                self.op_x*other.uy+self.op_y*other.uy\n            )\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvLaplacian.op_x","title":"op_x  <code>instance-attribute</code>","text":"<pre><code>op_x = ConvOperator(\n    CENTRAL_LAPLACIAN_SCHEMES[order],\n    direction=\"x\",\n    derivative=2,\n    device=device,\n    dtype=dtype,\n)\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvLaplacian.op_y","title":"op_y  <code>instance-attribute</code>","text":"<pre><code>op_y = ConvOperator(\n    CENTRAL_LAPLACIAN_SCHEMES[order],\n    direction=\"y\",\n    derivative=2,\n    device=device,\n    dtype=dtype,\n)\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvLaplacian.__init__","title":"__init__","text":"<pre><code>__init__(\n    order: int, device=\"cpu\", dtype=torch.float32\n) -&gt; None\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __init__(self, order: int, device=\"cpu\", dtype=torch.float32) -&gt; None:\n    self.op_x = ConvOperator(\n        CENTRAL_LAPLACIAN_SCHEMES[order], direction='x', derivative=2, device=device, dtype=dtype)\n    self.op_y = ConvOperator(\n        CENTRAL_LAPLACIAN_SCHEMES[order], direction='y', derivative=2, device=device, dtype=dtype)\n</code></pre>"},{"location":"contents/guide/operators/#ConvDO.conv_operators.ConvLaplacian.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>ConvDO/conv_operators.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, ScalarField):\n        return self.op_x*other+self.op_y*other\n    elif isinstance(other, VectorValue):\n        return VectorValue(\n            self.op_x*other.ux+self.op_y*other.ux,\n            self.op_x*other.uy+self.op_y*other.uy\n        )\n</code></pre>"}]}